[
    {
        "player0": "import math\n\n# Constants\nVELOCITY = 100.0\nSENSITIVITY = 0.3\nDISTANCE_FROM_ENTITY = 5.0\nJUMP_FORCE = 100.0\nFOVY_FORWARD = 80\nFOVY_BACKWARD = 60\n\n# Initial values\nyaw, pitch = 0.0, 0.0\ngrounded = False\nentity.visible = True\n\nmoving_forward_backwards = False\n\n# Function to convert spherical coordinates to Cartesian coordinates\ndef spherical_to_cartesian(radius, yaw, pitch):\n\tx = radius * math.cos(math.radians(yaw)) * math.cos(math.radians(pitch))\n\ty = radius * math.sin(math.radians(pitch))\n\tz = radius * math.sin(math.radians(yaw)) * math.cos(math.radians(pitch))\n\treturn Vector3(x, y, z)\n\ndef update():\n\tglobal yaw, pitch, grounded\n\n\thandle_movement()\n\thandle_camera_rotation()\n\tupdate_camera_position()\n\tcheck_ground()\n\tset_entity_rotation()\n\ndef handle_movement():\n\tglobal yaw, pitch, moving_forward_backwards\n\n\tcamera_direction = camera.front\n\tcamera_direction.y = 0\n\n\tdelta_time_vec3 = Vector3(time.dt, time.dt, time.dt)\n\n\t# Handle player movement inputs\n\tif IsKeyDown(KeyboardKey.KEY_W):\n\t\tmoving_forward_backwards = True\n\t\tentity.applyImpulse(camera_direction * delta_time_vec3 * VELOCITY)\n\telif IsKeyDown(KeyboardKey.KEY_S):\n\t\tmoving_forward_backwards = True\n\t\tentity.applyImpulse(camera.back * delta_time_vec3 * VELOCITY)\n\telif IsKeyDown(KeyboardKey.KEY_A):\n\t\tmoving_forward_backwards = False\n\t\tentity.applyImpulse(camera.left * delta_time_vec3 * VELOCITY)\n\telif IsKeyDown(KeyboardKey.KEY_D):\n\t\tmoving_forward_backwards = False\n\t\tentity.applyImpulse(camera.right * delta_time_vec3 * VELOCITY)\n\telif IsKeyPressed(KeyboardKey.KEY_SPACE) and grounded:\n\t\tentity.applyImpulse(Vector3(0, JUMP_FORCE, 0))\n\telse:\n\t\tmoving_forward_backwards = False\n\n\tif moving_forward_backwards:\n\t\tcamera.fovy = Lerp(camera.fovy, FOVY_FORWARD, time.dt)\n\telse:\n\t\tcamera.fovy = Lerp(camera.fovy, FOVY_BACKWARD, time.dt)\n\ndef handle_camera_rotation():\n\tglobal yaw, pitch\n\n\t# Handle mouse input for camera rotation\n\tyaw -= GetMouseMovement().x * SENSITIVITY\n\tpitch -= GetMouseMovement().y * SENSITIVITY\n\n\t# Clamp pitch to avoid camera flipping\n\tpitch = max(-89.0, min(89.0, pitch))\n\ndef update_camera_position():\n\tglobal yaw, pitch\n\n\t# Calculate the front direction based on yaw and pitch\n\tfront = Vector3(\n\t\tmath.cos(math.radians(yaw)) * math.cos(math.radians(pitch)),\n\t\tmath.sin(math.radians(pitch)),\n\t\t-math.sin(math.radians(yaw)) * math.cos(math.radians(pitch))\n\t)\n\n\t# Update camera position to rotate around the entity\n\tcamera.position = entity.position + spherical_to_cartesian(DISTANCE_FROM_ENTITY, -yaw, -pitch)\n\tcamera.look_at = entity.position\n\tcamera.up = Vector3(0, 1, 0)\n\ndef check_ground():\n\tglobal grounded\n\t\n\tray = Raycast(entity.position, Vector3(0, -1, 0), ignore=[entity])\n\t\n\t# Raycast starts in the center of the entity, not on the feets, for that reason, the raycast origin was pushed down.\n\tif ray.hit:\n\t\tgrounded = ray.distance <  entity.scale.y / 2 + 0.1\n\telse:\n\t\tgrounded = False\n\ndef set_entity_rotation():\n\t# Set entity rotation based on camera direction\n\tfront = Vector3(math.cos(math.radians(yaw)), 0, -math.sin(math.radians(yaw)))\n\tentity_rotation_yaw = math.degrees(math.atan2(front.z, front.x)) + 90.0\n\tentity_rotation_pitch = math.degrees(math.asin(front.y))\n\tentity.rotation = Vector3(0, -entity_rotation_yaw, 0)\n\n\n\n"
    }
]