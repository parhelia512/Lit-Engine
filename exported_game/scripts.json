[
    {
        "player0": "import math\n\n# Constants\nVELOCITY = 50.0\nSENSITIVITY = 0.3\nDISTANCE_FROM_ENTITY = 5.0\n\n# Initial values\nyaw, pitch = 0.0, 0.0\ngrounded = False\nentity.visible = True\n\n# Function to convert spherical coordinates to Cartesian coordinates\ndef spherical_to_cartesian(radius, yaw, pitch):\n    x = radius * math.cos(math.radians(yaw)) * math.cos(math.radians(pitch))\n    y = radius * math.sin(math.radians(pitch))\n    z = radius * math.sin(math.radians(yaw)) * math.cos(math.radians(pitch))\n    return Vector3(x, y, z)\n\ndef update():\n    global yaw, pitch, grounded\n\n    handle_movement()\n    handle_camera_rotation()\n    update_camera_position()\n    check_ground()\n    set_entity_rotation()\n\ndef handle_movement():\n    global yaw, pitch\n\n    camera_direction = camera.front * time.dt * VELOCITY\n    camera_direction.y = 0\n\n    DeltaTimeVec3 = Vector3(time.dt, time.dt, time.dt)\n\n    # Handle player movement inputs\n    if IsKeyDown(KeyboardKey.KEY_W):\n        entity.applyImpulse(camera_direction)\n    if IsKeyDown(KeyboardKey.KEY_S):\n        entity.applyImpulse(camera.back * DeltaTimeVec3 * VELOCITY)\n    if IsKeyDown(KeyboardKey.KEY_A):\n        left = camera.left * DeltaTimeVec3 * VELOCITY\n        entity.applyImpulse(left)\n    if IsKeyDown(KeyboardKey.KEY_D):\n        right = camera.right * DeltaTimeVec3 * VELOCITY\n        entity.applyImpulse(right)\n    if IsKeyPressed(KeyboardKey.KEY_SPACE) and grounded:\n        entity.applyImpulse(Vector3(0, VELOCITY * 1.8, 0))\n\ndef handle_camera_rotation():\n    global yaw, pitch\n\n    # Handle mouse input for camera rotation\n    yaw -= GetMouseMovement().x * SENSITIVITY\n    pitch -= GetMouseMovement().y * SENSITIVITY\n\n    # Clamp pitch to avoid camera flipping\n    pitch = max(-89.0, min(89.0, pitch))\n\ndef update_camera_position():\n    global yaw, pitch\n\n    # Calculate the front direction based on yaw and pitch\n    front = Vector3(\n        math.cos(math.radians(yaw)) * math.cos(math.radians(pitch)),\n        math.sin(math.radians(pitch)),\n        -math.sin(math.radians(yaw)) * math.cos(math.radians(pitch))\n    )\n\n    # Update camera position to rotate around the entity\n    camera.position = entity.position + spherical_to_cartesian(DISTANCE_FROM_ENTITY, -yaw, -pitch)\n    camera.look_at = entity.position\n    camera.up = Vector3(0, 1, 0)\n\ndef check_ground():\n    global grounded\n\n    ray = raycast(entity.position, Vector3(0, -1, 0), ignore=[entity])\n    if (ray.hit):\n        grounded = ray.distance < entity.scale.y / 2 + 0.01\n    else:\n        grounded = False\n\ndef set_entity_rotation():\n    # Set entity rotation based on camera direction\n    front = Vector3(math.cos(math.radians(yaw)), 0, -math.sin(math.radians(yaw)))\n    entity_rotation_yaw = math.degrees(math.atan2(front.z, front.x)) + 90.0\n    entity_rotation_pitch = math.degrees(math.asin(front.y))\n    entity.rotation = Vector3(0, -entity_rotation_yaw, 0)\n\n\n\n\n\n\n\n\n"
    }
]