[
    {
        "player0": "import math\n\nvelocity = 50.0\n\nyaw = 0.0\npitch = 0.0\n\ngrounded = False\nrotation_angle = 45.0\nentity.visible = True\n\n# Function to convert spherical coordinates to Cartesian coordinates\ndef spherical_to_cartesian(radius, yaw, pitch):\n    x = radius * math.cos(math.radians(yaw)) * math.cos(math.radians(pitch))\n    y = radius * math.sin(math.radians(pitch))\n    z = radius * math.sin(math.radians(yaw)) * math.cos(math.radians(pitch))\n    return Vector3(x, y, z)\n\ndef update():\n    global velocity, dragging_item, hovered_entity, yaw, pitch, grounded\n\n    camera_direction = camera.front * time.dt * velocity\n    camera_direction.y = 0\n\n    DeltaTimeVec3 = Vector3(time.dt, time.dt, time.dt)\n\n    if IsKeyDown(KeyboardKey.KEY_W):\n        entity.applyImpulse(camera_direction)\n\n    if IsKeyDown(KeyboardKey.KEY_S):\n        entity.applyImpulse(camera.back * DeltaTimeVec3 * velocity)\n\n    if IsKeyDown(KeyboardKey.KEY_A):\n        left = camera.left * DeltaTimeVec3 * velocity\n        entity.applyImpulse(left)\n\n    if IsKeyDown(KeyboardKey.KEY_D):\n        right = camera.right * DeltaTimeVec3 * velocity\n        entity.applyImpulse(right)\n\n    if IsKeyPressed(KeyboardKey.KEY_SPACE):\n        if grounded:\n            entity.applyImpulse(Vector3(0, velocity*3, 0))\n\n    sensitivity = 0.3\n    yaw -= GetMouseMovement().x * sensitivity\n    pitch -= GetMouseMovement().y * sensitivity\n\n    pitch = max(-89.0, min(89.0, pitch))\n\n    # Calculate the front direction based on yaw and pitch\n    front = Vector3(\n        math.cos(math.radians(yaw)) * math.cos(math.radians(pitch)),\n        math.sin(math.radians(pitch)),\n        -math.sin(math.radians(yaw)) * math.cos(math.radians(pitch))\n    )\n\n    # Update camera position to rotate around the entity\n    distance_from_entity = 5.0  # Adjust this value to change the distance from the entity\n    camera.position = entity.position + spherical_to_cartesian(distance_from_entity, -yaw, -pitch)\n\n    camera.look_at = entity.position\n    camera.up = Vector3(0, 1, 0)\n\n    distance = raycast(\n        entity.position,\n        Vector3(0, -1, 0),\n        ignore=[entity]\n    ).distance\n\n    grounded = distance < entity.scale.y / 2 + 0.01\n\n    # Calculate rotation for the entity based on camera direction\n    entity_rotation_yaw = math.degrees(math.atan2(front.z, front.x)) + 90.0\n    entity_rotation_pitch = math.degrees(math.asin(front.y))\n\n    # Set entity rotation\n    entity.rotation = Vector3(0, -entity_rotation_yaw, 0)\n\n\n"
    }
]